# 概述
## 消费模型
消息代理把消息发送出去后，当消费进程挂掉或者由于网络原因没有收到这条消息时，就有可能造成消息丢失(因为消息代理已经把这条消息标记为己消费了，但实际上这条消息并没有被实际处理)。如果要保证消息的处理语义，消息代理发送完消息后，要设置状态为“已发送”，只有收到消费者的确认请求后才更新为“已消费”，这就需要在消息代理中记录所有消息的消费状态，这种做法也是不可取的。  
Kafka采用拉取模型.  
Kafka的做法是生产者发布的所有消息会一直保存在Kafka集群中，不管消息有没有被消费。用户可以通过设置保留时间来清理过期的数据.  
## 分布式模型
如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负载均衡到所有的消费者;如果要实现“发布-订阅”模型，则每个消费者的消费组名称都不相同，这样每条消息就会广播给所有的消费者。  
## 设计与实现
使用“零拷贝技术”(zero-copy)只需将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中.  
所有消息代理节点都会保存一份相同的元数据，这份元数据记录了每个主题分区对应的主副本节点。生严者客户端在发送消息之前，会向任意一个代理节点请求元数据，井确定每条消息对应的目标节点然后把消息直接发送给对应的目标节点。  
对于分区语义，Kafka暴露了一个接口，允许用户指定消息的键如何参与分区。  
分区的主副本都在同一个服务器上(见图1-10左图)，就会存在数据热点问题。因此，分区的主副本应该均匀地分配到各个服务器上(见图1-10右图)。通常，分区的数量要比服务器多很多，所以每个服务器都可以成为一些分区的主副本，也能同时成为一些分区的备份副本。  
每个分区的主副本会跟踪正在同步中的备份副本节点(In Sync Replicas，即ISR)。  
在Kafka中，一条消息只有被ISR集合的所有副本都运用到本地的日志文件，才会认为消息被成功提交了。任何时刻，只要ISR至少有一个副本是存活的，Kafka就可以保证“→条消息一旦被提交，就不会丢失”。只有已经提交的消息才能被消费者消费，因此消费者不用担心会看到因为主副本失败而丢失的消息。  
默认的`log.dirs=/tmp/kafka-logs` 目录下还会记录所有分区的偏移盘全局状态数据，比如检查点(checkpoint)和恢复点(recovery)。 
Kafka不保证全局的消息顺序，只保证分区级别的消息顺序.  
服务器挂掉又重启后，分区的主副本并没有变化。观察上面的输出结果，可以看到编号为2的节点有3个分区在上面。为了保证主副本会负载均衡到所有的服务器，可以执行`preferred-replica-election`脚本来手动执行平衡操作，即选择Replicas的第一个副本作为分区的主副本。  